@techreport{ietf-dtn-amm-05,
    number =    {draft-ietf-dtn-amm-05},
    type =      {Internet-Draft},
    institution =   {Internet Engineering Task Force},
    publisher = {Internet Engineering Task Force},
    note =      {Work in Progress},
    url =       {https://datatracker.ietf.org/doc/draft-ietf-dtn-amm/05/},
    author =    {Edward J. Birrane and Brian Sipos and Justin Ethier},
    title =     {{DTNMA Application Management Model (AMM) and Data Models}},
    pagetotal = 88,
    year =      2025,
    month =     jul,
    day =       3,
    abstract =  {This document defines a model that captures the information necessary to asynchronously manage applications within the Delay-Tolerant Networking Management Architecture (DTNMA). This model provides a set of common managed object types, data types and structures, and a template for information needed within each application data model. The built-in definitions are made to be extensible by applications without needing to modify core Agent or Manager behavior.},
}
@techreport{ietf-dtn-ari-06,
    number =    {draft-ietf-dtn-ari-06},
    type =      {Internet-Draft},
    institution =   {Internet Engineering Task Force},
    publisher = {Internet Engineering Task Force},
    note =      {Work in Progress},
    url =       {https://datatracker.ietf.org/doc/draft-ietf-dtn-ari/06/},
    author =    {Edward J. Birrane and Emery Annis and Brian Sipos},
    title =     {{DTNMA Application Resource Identifier (ARI)}},
    pagetotal = 65,
    year =      2025,
    month =     jul,
    day =       3,
    abstract =  {This document defines the structure, format, and features of the naming scheme for the objects defined in the Delay-Tolerant Networking Management Architecture (DTNMA) Application Management Model (AMM), in support of challenged network management solutions described in the DTNMA document. This document defines the DTNMA Application Resource Identifier (ARI), using a text-form based on the common Uniform Resource Identifier (URI) and a binary-form based on Concise Binary Object Representation (CBOR). These meet the needs for a concise, typed, parameterized, and hierarchically organized set of managed data elements.},
}
@techreport{ietf-dtn-adm-00,
    number =    {draft-ietf-dtn-adm-00},
    type =      {Internet-Draft},
    institution =   {Internet Engineering Task Force},
    publisher = {Internet Engineering Task Force},
    note =      {Work in Progress},
    url =       {https://datatracker.ietf.org/doc/draft-ietf-dtn-adm/00/},
    author =    {Edward J. Birrane and Brian Sipos and Justin Ethier},
    title =     {{DTNMA Application Management Model (AMM) and Data Models}},
    pagetotal = 121,
    year =      2024,
    month =     feb,
    day =       22,
    abstract =  {This document defines a data model that captures the information necessary to asynchronously manage applications within the Delay- Tolerant Networking Management Architecture (DTNMA). This model provides a set of common type definitions, data structures, and a template for publishing standardized representations of model elements.},
}
@techreport{ietf-dtn-amp-02,
    number =    {draft-ietf-dtn-amp-02},
    type =      {Internet-Draft},
    institution =   {Internet Engineering Task Force},
    publisher = {Internet Engineering Task Force},
    note =      {Work in Progress},
    url =       {https://datatracker.ietf.org/doc/draft-ietf-dtn-amp/02/},
    author =    {Edward J. Birrane and Brian Sipos},
    title =     {{DTNMA Asynchronous Management Protocol (AMP)}},
    pagetotal = 14,
    year =      2025,
    month =     may,
    day =       28,
    abstract =  {This document defines a messaging protocol for the Delay-Tolerant Networking (DTN) Management Architecture (DTNMA) Asynchronous Management Model (AMM) and a transport binding for exchanging those messages over a network. This Asynchronous Management Protocol (AMP) does not require transport-layer sessions, operates over unidirectional links, and seeks to reduce the energy and compute power necessary for performing remote management of resource constrained devices possibly over challenged networks.},
}
@misc{rfc3339,
    series =    {Request for Comments},
    number =    3339,
    howpublished =  {RFC 3339},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC3339},
    url =       {https://www.rfc-editor.org/info/rfc3339},
    author =    {Chris Newman and Graham Klyne},
    title =     {{Date and Time on the Internet: Timestamps}},
    pagetotal = 18,
    year =      2002,
    month =     jul,
    abstract =  {This document defines a date and time format for use in Internet protocols that is a profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.},
}
@misc{rfc3986,
    series =    {Request for Comments},
    number =    3986,
    howpublished =  {RFC 3986},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC3986},
    url =       {https://www.rfc-editor.org/info/rfc3986},
    author =    {Tim Berners-Lee and Roy T. Fielding and Larry M Masinter},
    title =     {{Uniform Resource Identifier (URI): Generic Syntax}},
    pagetotal = 61,
    year =      2005,
    month =     jan,
    abstract =  {A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource. This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet. The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier. This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme. {[}STANDARDS-TRACK{]}},
}
@misc{rfc4648,
    series =    {Request for Comments},
    number =    4648,
    howpublished =  {RFC 4648},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC4648},
    url =       {https://www.rfc-editor.org/info/rfc4648},
    author =    {Simon Josefsson},
    title =     {{The Base16, Base32, and Base64 Data Encodings}},
    pagetotal = 18,
    year =      2006,
    month =     oct,
    abstract =  {This document describes the commonly used base 64, base 32, and base 16 encoding schemes. It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings. {[}STANDARDS-TRACK{]}},
}
@misc{rfc8259,
    series =    {Request for Comments},
    number =    8259,
    howpublished =  {RFC 8259},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC8259},
    url =       {https://www.rfc-editor.org/info/rfc8259},
    author =    {Tim Bray},
    title =     {{The JavaScript Object Notation (JSON) Data Interchange Format}},
    pagetotal = 16,
    year =      2017,
    month =     dec,
    abstract =  {JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format. It was derived from the ECMAScript Programming Language Standard. JSON defines a small set of formatting rules for the portable representation of structured data. This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.},
}
@misc{rfc8610,
    series =    {Request for Comments},
    number =    8610,
    howpublished =  {RFC 8610},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC8610},
    url =       {https://www.rfc-editor.org/info/rfc8610},
    author =    {Henk Birkholz and Christoph Vigano and Carsten Bormann},
    title =     {{Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures}},
    pagetotal = 64,
    year =      2019,
    month =     jun,
    abstract =  {This document proposes a notational convention to express Concise Binary Object Representation (CBOR) data structures (RFC 7049). Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON.},
}
@misc{rfc8742,
    series =    {Request for Comments},
    number =    8742,
    howpublished =  {RFC 8742},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC8742},
    url =       {https://www.rfc-editor.org/info/rfc8742},
    author =    {Carsten Bormann},
    title =     {{Concise Binary Object Representation (CBOR) Sequences}},
    pagetotal = 10,
    year =      2020,
    month =     feb,
    abstract =  {This document describes the Concise Binary Object Representation (CBOR) Sequence format and associated media type "application/cbor-seq". A CBOR Sequence consists of any number of encoded CBOR data items, simply concatenated in sequence. Structured syntax suffixes for media types allow other media types to build on them and make it explicit that they are built on an existing media type as their foundation. This specification defines and registers "+cbor-seq" as a structured syntax suffix for CBOR Sequences.},
}
@misc{rfc8943,
    series =    {Request for Comments},
    number =    8943,
    howpublished =  {RFC 8943},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC8943},
    url =       {https://www.rfc-editor.org/info/rfc8943},
    author =    {Michael B. Jones and Anthony Nadalin and Joerg Richter},
    title =     {{Concise Binary Object Representation (CBOR) Tags for Date}},
    pagetotal = 6,
    year =      2020,
    month =     nov,
    abstract =  {The Concise Binary Object Representation (CBOR), as specified in RFC 7049, is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. In CBOR, one point of extensibility is the definition of CBOR tags. RFC 7049 defines two tags for time: CBOR tag 0 (date/time string as per RFC 3339) and tag 1 (POSIX "seconds since the epoch"). Since then, additional requirements have become known. This specification defines a CBOR tag for a date text string (as per RFC 3339) for applications needing a textual date representation within the Gregorian calendar without a time. It also defines a CBOR tag for days since the date 1970-01-01 in the Gregorian calendar for applications needing a numeric date representation without a time. This specification is the reference document for IANA registration of the CBOR tags defined.},
}
@misc{rfc9171,
    series =    {Request for Comments},
    number =    9171,
    howpublished =  {RFC 9171},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC9171},
    url =       {https://www.rfc-editor.org/info/rfc9171},
    author =    {Scott Burleigh and Kevin Fall and Edward J. Birrane},
    title =     {{Bundle Protocol Version 7}},
    pagetotal = 53,
    year =      2022,
    month =     jan,
    abstract =  {This document presents a specification for the Bundle Protocol, adapted from the experimental Bundle Protocol specification developed by the Delay-Tolerant Networking Research Group of the Internet Research Task Force and documented in RFC 5050.},
}
@misc{rfc9675,
    series =    {Request for Comments},
    number =    9675,
    howpublished =  {RFC 9675},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC9675},
    url =       {https://www.rfc-editor.org/info/rfc9675},
    author =    {Edward J. Birrane and Sarah Heiner and Emery Annis},
    title =     {{Delay-Tolerant Networking Management Architecture (DTNMA)}},
    pagetotal = 49,
    year =      2024,
    month =     nov,
    abstract =  {The Delay-Tolerant Networking (DTN) architecture describes a type of challenged network in which communications may be significantly affected by long signal propagation delays, frequent link disruptions, or both. The unique characteristics of this environment require a unique approach to network management that supports asynchronous transport, autonomous local control, and a small footprint (in both resources and dependencies) so as to deploy on constrained devices. This document describes a DTN Management Architecture (DTNMA) suitable for managing devices in any challenged environment but, in particular, those communicating using the DTN Bundle Protocol (BP). Operating over BP requires an architecture that neither presumes synchronized transport behavior nor relies on query-response mechanisms. Implementations compliant with this DTNMA should expect to successfully operate in extremely challenging conditions, such as over unidirectional links and other places where BP is the preferred transport.},
}
