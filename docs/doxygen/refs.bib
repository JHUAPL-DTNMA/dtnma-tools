@techreport{ietf-dtn-ari-00,
    number =    {draft-ietf-dtn-ari-00},
    type =      {Internet-Draft},
    institution =   {Internet Engineering Task Force},
    publisher = {Internet Engineering Task Force},
    note =      {Work in Progress},
    url =       {https://datatracker.ietf.org/doc/draft-ietf-dtn-ari/00/},
    author =    {Edward J. Birrane and Emery Annis and Brian Sipos},
    title =     {{DTNMA Application Resource Identifier (ARI)}},
    pagetotal = 44,
    year =      2024,
    month =     feb,
    day =       22,
    abstract =  {This document defines the structure, format, and features of the naming scheme for the objects defined in the Delay-Tolerant Networking Management Architecture (DTNMA) Application Management Model (AMM), in support of challenged network management solutions described in the DTNMA document. This document defines the DTNMA Application Resource Identifier (ARI), using a text-form based on the common Uniform Resource Identifier (URI) and a binary-form based on Concise Binary Object Representation (CBOR). These meet the needs for a concise, typed, parameterized, and hierarchically organized set of managed data elements.},
}
@techreport{ietf-dtn-adm-00,
    number =    {draft-ietf-dtn-adm-00},
    type =      {Internet-Draft},
    institution =   {Internet Engineering Task Force},
    publisher = {Internet Engineering Task Force},
    note =      {Work in Progress},
    url =       {https://datatracker.ietf.org/doc/draft-ietf-dtn-adm/00/},
    author =    {Edward J. Birrane and Brian Sipos and Justin Ethier},
    title =     {{DTNMA Application Management Model (AMM) and Data Models}},
    pagetotal = 121,
    year =      2024,
    month =     feb,
    day =       22,
    abstract =  {This document defines a data model that captures the information necessary to asynchronously manage applications within the Delay- Tolerant Networking Management Architecture (DTNMA). This model provides a set of common type definitions, data structures, and a template for publishing standardized representations of model elements.},
}
@misc{rfc3339,
    series =    {Request for Comments},
    number =    3339,
    howpublished =  {RFC 3339},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC3339},
    url =       {https://www.rfc-editor.org/info/rfc3339},
    author =    {Chris Newman and Graham Klyne},
    title =     {{Date and Time on the Internet: Timestamps}},
    pagetotal = 18,
    year =      2002,
    month =     jul,
    abstract =  {This document defines a date and time format for use in Internet protocols that is a profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.},
}
@misc{rfc3986,
    series =    {Request for Comments},
    number =    3986,
    howpublished =  {RFC 3986},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC3986},
    url =       {https://www.rfc-editor.org/info/rfc3986},
    author =    {Tim Berners-Lee and Roy T. Fielding and Larry M Masinter},
    title =     {{Uniform Resource Identifier (URI): Generic Syntax}},
    pagetotal = 61,
    year =      2005,
    month =     jan,
    abstract =  {A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource. This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet. The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier. This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme. {[}STANDARDS-TRACK{]}},
}
@misc{rfc4648,
    series =    {Request for Comments},
    number =    4648,
    howpublished =  {RFC 4648},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC4648},
    url =       {https://www.rfc-editor.org/info/rfc4648},
    author =    {Simon Josefsson},
    title =     {{The Base16, Base32, and Base64 Data Encodings}},
    pagetotal = 18,
    year =      2006,
    month =     oct,
    abstract =  {This document describes the commonly used base 64, base 32, and base 16 encoding schemes. It also discusses the use of line-feeds in encoded data, use of padding in encoded data, use of non-alphabet characters in encoded data, use of different encoding alphabets, and canonical encodings. {[}STANDARDS-TRACK{]}},
}
@misc{rfc8259,
    series =    {Request for Comments},
    number =    8259,
    howpublished =  {RFC 8259},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC8259},
    url =       {https://www.rfc-editor.org/info/rfc8259},
    author =    {Tim Bray},
    title =     {{The JavaScript Object Notation (JSON) Data Interchange Format}},
    pagetotal = 16,
    year =      2017,
    month =     dec,
    abstract =  {JavaScript Object Notation (JSON) is a lightweight, text-based, language-independent data interchange format. It was derived from the ECMAScript Programming Language Standard. JSON defines a small set of formatting rules for the portable representation of structured data. This document removes inconsistencies with other specifications of JSON, repairs specification errors, and offers experience-based interoperability guidance.},
}
@misc{rfc8610,
    series =    {Request for Comments},
    number =    8610,
    howpublished =  {RFC 8610},
    publisher = {RFC Editor},
    doi =       {10.17487/RFC8610},
    url =       {https://www.rfc-editor.org/info/rfc8610},
    author =    {Henk Birkholz and Christoph Vigano and Carsten Bormann},
    title =     {{Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures}},
    pagetotal = 64,
    year =      2019,
    month =     jun,
    abstract =  {This document proposes a notational convention to express Concise Binary Object Representation (CBOR) data structures (RFC 7049). Its main goal is to provide an easy and unambiguous way to express structures for protocol messages and data formats that use CBOR or JSON.},
}
